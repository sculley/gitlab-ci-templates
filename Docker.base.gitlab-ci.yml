image: docker:latest

variables:
  # When using dind service, we need to instruct docker to talk with
  # the daemon started inside of the service. The daemon is available
  # with a network connection instead of the default
  # /var/run/docker.sock socket.
  # port 2375 for no TLS connection (insecure)
  # port 2376 for TLS connection
  DOCKER_HOST: tcp://docker:2376

  # Specify to Docker where to create the certificates, Docker will
  # create them automatically on boot, and will create
  # `/certs/client` that will be shared between the service and job
  # container, thanks to volume mount from config.toml
  DOCKER_TLS_CERTDIR: "/certs"
  
  # These are usually specified by the entrypoint, however the
  # Kubernetes executor doesn't run entrypoints
  # https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4125
  DOCKER_TLS_VERIFY: 1
  DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"

  # These are for buildx
  DOCKER_DRIVER: overlay2
  DOCKER_BUILDKIT: 1
  DOCKER_CLI_EXPERIMENTAL: enabled
  BUILDX_URL: https://github.com/docker/buildx/releases/download/v0.5.1/buildx-v0.5.1.linux-amd64
  BUILDX_BUILDER: buildx
  # Name/Location of the file containing any build-args to add
  # If this file doesn't exist, then we don't build the image
  # with any build-args
  BUILD_ARG_FILE: Docker.build.args

services:
  - name: docker:dind
    command: ["--experimental"]

.build_setup:
  # This is used by other jobs
  script:
    # https://gitlab.com/gitlab-org/gitlab-runner/-/issues/27384#note_497228752
    - |
      for i in $(seq 1 30)
      do
          docker info && break
          echo "Waiting for docker to start"
          sleep 1s
      done
    - |
      mkdir -p $HOME/.docker
      echo -e '{\n  "experimental": "enabled"\n}' | tee $HOME/.docker/config.json
      mkdir -p $HOME/.docker/cli-plugins/
      wget -O $HOME/.docker/cli-plugins/docker-buildx $BUILDX_URL
      chmod a+x $HOME/.docker/cli-plugins/docker-buildx
    - docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
    - docker context create pipeline-builder
    - docker buildx create pipeline-builder --use --driver docker-container --name ${BUILDX_BUILDER}
    - docker buildx inspect --bootstrap ${BUILDX_BUILDER}
    - docker version
    - docker buildx
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY

.build:
  stage: build
  script:
    # Builds an linux/amd64 version of the image, the Dockerfile must be platform
    # independent i.e. you can't use platform specific packages or pass through
    # variables to handle this
    - !reference [.build_setup, script]
    - |
      echo "Identifiying the build args/image.."
      if [ -f "$BUILD_ARG_FILE" ];
      then
        BUILD_ARGS=$(cat $BUILD_ARG_FILE | sed 's/^/--build-arg /g' | paste -s -d " ")
        BUILD_CMD="--tag ${BUILD_IMAGE}-amd64 ${BUILD_ARGS}"
        
      else
        BUILD_CMD="-t ${BUILD_IMAGE}-amd64"
      fi
    - echo "Building ${BUILD_IMAGE}-amd64"
    - docker buildx build --push --platform linux/amd64 ${BUILD_CMD} .

.build-arm64:
  stage: build
  script:
    # Builds an linux/arm64 version of the image, the Dockerfile must be platform
    # independent i.e. you can't use platform specific packages or pass through
    # variables to handle this
    - !reference [.build_setup, script]
    - |
      echo "Identifiying the build args/image.."
      if [ -f "$BUILD_ARG_FILE" ];
      then
        BUILD_ARGS=$(cat $BUILD_ARG_FILE | sed 's/^/--build-arg /g' | paste -s -d " ")
        BUILD_CMD="--tag ${BUILD_IMAGE}-arm64 ${BUILD_ARGS}"
        
      else
        BUILD_CMD="-t ${BUILD_IMAGE}-arm64"
      fi
    - echo "Building ${BUILD_IMAGE}-arm64"
    - docker buildx build --push --platform linux/arm64 ${BUILD_CMD} .

.push:
  stage: push
  variables:
    # Requires the PUBLISH_AMD|ARM_IMAGE to be present, override these
    # in the parent job to control which images are pushed to the external
    # registry
    PUBLISH_AMD_IMAGE: "true"
    PUBLISH_ARM_IMAGE: "true"
    PUBLISH_IMAGE: "$EXTERNAL_REGISTRY_URL:$BUILD_TAG"
  script:
    - !reference [.build_setup, script]
    - |
      echo "Pushing image ${BUILD_TAG} to $EXTERNAL_REGISTRY_URL"
      if [ -n "$PUBLISH_AMD_IMAGE" ] && [ -z "$PUBLISH_ARM_IMAGE" ];
      then
        # push amd64
        docker pull ${BUILD_IMAGE}-amd64
        docker tag ${BUILD_IMAGE}-amd64 $PUBLISH_IMAGE-amd64
        docker push $PUBLISH_IMAGE-amd64
        echo "Pushed $PUBLISH_IMAGE-amd64"
      elif [ -n "$PUBLISH_ARM_IMAGE" ] && [ -z "$PUBLISH_AMD_IMAGE" ];
      then
        # push amd64
        docker pull ${BUILD_IMAGE}-arm64
        docker tag ${BUILD_IMAGE}-arm64 $PUBLISH_IMAGE-arm64
        docker push "$PUBLISH_IMAGE-arm64
        echo "Pushed $PUBLISH_IMAGE-arm64"
      elif [ -n "$PUBLISH_AMD_IMAGE" ] && [ -n "$PUBLISH_ARM_IMAGE" ];
      then
        # Push both amd64/arm64 and create single image manifest using both amd64/arm64 images
        docker pull ${BUILD_IMAGE}-amd64
        docker tag ${BUILD_IMAGE}-amd64 $PUBLISH_IMAGE-amd64
        docker push $PUBLISH_IMAGE-amd64
        echo "Pushed $PUBLISH_IMAGE-amd64"
        echo -e
        docker pull ${BUILD_IMAGE}-arm64
        docker tag ${BUILD_IMAGE}-arm64 $PUBLISH_IMAGE-arm64
        docker push "$PUBLISH_IMAGE-arm64
        echo "Pushed $PUBLISH_IMAGE-arm64"
        echo -e
        echo "Building manifiest $PUBLISH_IMAGE using images $PUBLISH_IMAGE-amd64 $PUBLISH_IMAGE-arm64"
        docker manifest create $PUBLISH_IMAGE $PUBLISH_IMAGE-amd64 $PUBLISH_IMAGE-arm64
        docker manifest push $PUBLISH_IMAGE
        echo "Pushed $PUBLISH_IMAGE"
      else
        echo "PUBLISH_AMD_IMAGE or PUBLISH_ARM_IMAGE not set, unable to publish..."
      fi
